% Une ligne commentaire débute par le caractère « % »

\documentclass[a4paper]{article}

% Options possibles : 10pt, 11pt, 12pt (taille de la fonte)
%                     oneside, twoside (recto simple, recto-verso)
%                     draft, final (stade de développement)

\usepackage[utf8]{inputenc}   % LaTeX, comprends les accents !
\usepackage[T1]{fontenc}      % Police contenant les caractères français
\usepackage[francais]{babel}
\usepackage{fullpage}
\usepackage{multicol}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=red
    }
\usepackage{bookmark}
\usepackage{blindtext}
\setlength\columnsep{30pt}
\usepackage{algorithm2e}
\SetKwComment{Comment}{/* }{ */}
\RestyleAlgo{ruled}


\usepackage{graphicx}  % pour inclure des images
\graphicspath{ {rapport/img/} }

%\pagestyle{headings}        % Pour mettre des entêtes avec les titres
                              % des sections en haut de page

\title{  TP1 : Analyse statique\\Évolution et restructuration des logiciels}
\author{Mohamad Satea Almallouhi - Tony Nguyen\\\emph{M1 Génie Logiciel}\\Faculté des Sciences\\Université de Montpellier.}
\date{6 octobre 2024}



\begin{document}
    \maketitle
    \begin{center}
        % \includegraphics[height=.95\textwidth]{power}
    \end{center}

    \begin{abstract}     % Résumé du travail
      \emph{Rapport d'exercice sur l'analyse statique}
    \end{abstract}
    \newpage
    %\dominitoc  % initializer les minitoc
    \tableofcontents
    \section*{Introduction}
            \addcontentsline{toc}{section}{Introduction}
            \paragraph{}
                Dans le cadre de l'Unité d'Enseignement Évolution et restructuration des logiciels, nous allons analysés un programme en observant son code source de manière statique. L'étape d'extraction des informations a été réalisé précédement. Nous nous trouvons à présent dans l'étape de traitement des propriétés dans le workflow. Nous allons étudier le concept de couplage des classes.

                Tout d'abord, à partir du travail précédent, nous allons nous servir du graph d'appel des méthodes écrites dans les classes du projet analysé. Cela nous permettra de calculer le couplage entre les différentes classes.

                Ainsi, grâce au graph de couplage, nous allons partitioné notre ensemble de classes en différent modules.
        \section*{Démonstration vidéo}
            \addcontentsline{toc}{section}{Démonstration}
            \paragraph{}
                En ligne sur Youtube, à l'adresse URL 
                % \url{https://youtu.be/fDvHlrK8IRg} 
                une démonstration vidéo de notre travail.
        \section*{Installation}
            \addcontentsline{toc}{section}{Installation}
            \paragraph{}
                Vous trouverez les instructions dans le README.md

    \newpage
    \begin{multicols}{2}
        [
            To Do
            \begin{itemize}
                \item add code picture 
                \item add resultat picture
                \item diagram class visiteur
                \item diagram class de l'app
                \item definition du couplage avec écritures math
                \item tous les algo en latex stylé
                \item → !!! → vidéo ← !!! ← 
            \end{itemize}
            Faire une vidéo, le rapport avec des screenshot des résultats et du code et enfin un read.md(instruction). En plus, pour le bonus, faire une belle application, des tests unitaires, faire le rapport en Latex.
        ]
        \section{UML!!!!}

        \section{Graphes}
        \paragraph{} 
        Nous nous intéressons au couplage entre les classes de notre application. Il serait logique de réunir les classes fortement dépendantes les unes des autres. De la même façon, les classes qui n'ont aucun rapport entre elle, pour des raisons de clarté, peuvent être isolé.
        \subsection{Algorithmes de création du graphe d'appel}
        \paragraph{} La construction de ce graph est la base de ce travail. Il nous permettra ensuite de calculer le couplage entre les classes ...

        Les méthodes qui se surchage entre elles (les méthodes ayant le même nom dans une classe mais avec une signature différente) sont confondues.
        \subsection{Le couplage}
        \paragraph{Définition} TODO INSERT EPIC MATH FORMULA HERE 
        \subsection{Graphe de couplage inter-classes}

        \paragraph{UML} TODO INSERT EPIC CLASS DIAGRAM HERE 
        \subsection{Montrer les visiteur}
        ???
        \section{Clusturing}
        Nous allons maintenant voir comment nous avons rassemblé les classes entre elles. 
        \subsection{Algorithme de clustering}
        \paragraph{Dendrogramme}
        \subsection{Identification des modules}
        \paragraph{Partitionnement des classes}
        \section{Spoon}
    \end{multicols}

\begin{algorithm}
\caption{An algorithm to make call graph}\label{alg:appel}
\KwData{$programme$}
\KwResult{$graphe\ d'appel$}
$g \gets new\ Graph() $\;
\For{each class c}{
    \For{each method m implemented in c}{
        \For{each method invoqued i in m}{
            \If{!isExternalMethod(i)} {
                $g.addSommet(m)$\;
                $g.addSommet(i)$
                \Comment*[r]{ajout des sommets m et i}

                $g.addVertex(m,i)$ \Comment*[r]{ajoute une arete de m vers i}

            }
        }
    }
}
$return\ g$\;
\end{algorithm}
\begin{algorithm}
\caption{An algorithm to make a weighted graph corresponding to the coupling between class}\label{alg:coupling}
\KwData{$le\ graphe\ d'appel$}
\KwResult{$graphe\ pondere$}
$graphPondere \gets new\ GraphPondere() $\;
\Comment{Produit cartésion entre toutes les classes de l'application en retirant les couples identiques (x,x)}
\For{each String aClassName1 in classNameSet}{
    \For{each String aClassName2 in classNameSet}{
        \If{aClassName1 != aClassName2} {

            $cpValue \gets calculCouplageValueEntre(aClassName1, aClassName2)$\;

            \If{cpValue > 0} {
                $graphPondere.addArete(aClassName1,aClassName2,cpValue)$\;
            }
        }
    }
    }
    $return\ graphPondere$\;
\end{algorithm}
\begin{algorithm}
    \paragraph{UML} INSERT UML CLASS DIAGRAM OF Cluster composite pattern
\caption{Clustering algorithm (Creating the Dendrogramme)}\label{alg:appel}
\KwData{$graph\ d'appel$}
\KwResult{$the\ dendrogramme$}
\Comment{Stratégie: toutes les class sont leurs propres cluster. On va essayer de fusioner les clusters entre eux en fonction du couplage}
$clusters \gets Cluster[]$\;
\For{each String aClassName in classNameSet}{
    $clusters.add(new\ Leaf(aClassName))$\;
}
$i \gets 0$\;
$Node root \gets null$\;
\While{i < size(clusters)} {
    $n \gets laFusionEntreLes2CLustersLesPlusProche()$\;
    $on\ retire\ les\ 2\ enfants\ du\ noeud\ n$\;
    $clusters.add(n)$\;
    $i++$\;
}
$return\ root$\;
\end{algorithm}
\begin{algorithm}
    \caption{Identification des modules}\label{alg:appel}
    \KwData{$dendrogramme\ root$}
    \KwResult{$Partitionnement\ en\ modules$}
    $result$\Comment{   une liste d'ensemble de String}
    $auxGetModule(root, result)$\;
    $return result$\;
\end{algorithm}
\begin{algorithm}
    \caption{auxGetModule}\label{alg:appel}
    \KwData{$dendrogramme\ root$}
    \KwResult{$Partitionnement\ en\ modules$}
    \eIf{root possède une valeur de couplage suffisante ou si c'est une feuille} {
        on a trouvé un module
    } {on fait la même chose au enfants de root de façon récursive}
\end{algorithm}
\end{document}